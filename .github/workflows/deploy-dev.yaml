name: Deploy to Dev

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
    branches:
      - develop
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false
# permissions: OIDC Ïù∏Ï¶ùÏóê ÌïÑÏöîÌïú Í∂åÌïú
permissions:
  id-token: write # OIDC ÌÜ†ÌÅ∞ Î∞úÍ∏â
  contents: read # ÏΩîÎìú ÏùΩÍ∏∞
  packages: write # Ìå®ÌÇ§ÏßÄ Ïì∞Í∏∞ (ECR)
# env: ÌôòÍ≤ΩÎ≥ÄÏàò (GitHub VariablesÏóêÏÑú Í∞ÄÏ†∏Ïò¥)
env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
  EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
  ENVIRONMENT: dev

jobs:
  build-and-deploy:
    name: üèóÔ∏è Build & Deploy (Dev)
    runs-on: ubuntu-latest
    environment: dev # ‚≠ê GitHub Environment ÏÇ¨Ïö© (Secret Î∂ÑÎ¶¨)
    if: ${{ github.event.workflow_run.conclusion == 'success' }} # CIÍ∞Ä "ÏÑ±Í≥µ"ÌñàÏùÑ ÎïåÎßå Ïã§Ìñâ

    steps:
      # Step 1: ÏΩîÎìú Ï≤¥ÌÅ¨ÏïÑÏõÉ
      - name: üì• Checkout code
        uses: actions/checkout@v5
      # Step 2: AWS Ïù∏Ï¶ù (OIDC)
      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: gha-dev-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
      # Step 3: ECR Î°úÍ∑∏Ïù∏
      - name: üîê Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      # Step 4: Docker Buildx ÏÑ§Ï†ï
      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      # Step 5: Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú & ECR Push
      - name: üê≥ Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./app
          push: true
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_SHA=${{ github.sha }}
            VERSION=${{ steps.meta.outputs.version }}
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest-dev
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:dev-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      # Step 6: kubectl ÏÑ§Ï†ï
      - name: üîß Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "latest"

      - name: üîó Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ env.EKS_CLUSTER_NAME }}
      - name: üöÄ Deploy to Dev
        run: |
          cd kustomize/overlays/dev

          # Ïù¥ÎØ∏ÏßÄ ÌÉúÍ∑∏ ÏóÖÎç∞Ïù¥Ìä∏
          kustomize edit set image \
            app=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest-dev

          # Î∞∞Ìè¨ (SAÎäî Ïù¥ÎØ∏ TerraformÏóêÏÑú ÏÉùÏÑ±Îê®)
          kubectl apply -k .

          # Î°§ÏïÑÏõÉ ÎåÄÍ∏∞
          kubectl rollout status deployment/app -n app-dev --timeout=180s

      - name: üè• Run health check
        run: |
          kubectl port-forward svc/app-svc 8080:80 -n app-dev &
          PF_PID=$!

          MAX_RETRIES=15
          for i in $(seq 1 $MAX_RETRIES); do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              http://localhost:8080/api/v1/health 2>/dev/null || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Health check passed! (attempt $i)"
              kill $PF_PID 2>/dev/null || true
              exit 0
            fi
            echo "‚è≥ Attempt $i/$MAX_RETRIES - HTTP $HTTP_STATUS"
            sleep 5
          done

          kill $PF_PID 2>/dev/null || true
          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: ‚è™ Rollback on failure
        if: failure()
        run: |
          kubectl rollout undo deployment/app -n app-dev
          kubectl rollout status deployment/app -n app-dev --timeout=120s

      - name: üì¢ Notify Slack
        if: always()
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": "Dev Deploy: ${{ job.status }}",
              "blocks": [
                 {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Dev Deploy Finished* :${{ job.status == 'success' && 'white_check_mark' || 'x' }}:\nBranch: `develop`"
                  }
                }
              ]
            }
